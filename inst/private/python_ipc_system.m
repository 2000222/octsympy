function [A,out] = python_ipc_system(what, cmd, varargin)
% "out" is provided for debugging

  persistent show_msg

  if (strcmp(what, 'reset'))
    show_msg = [];
    A = true;
    out = [];
    return
  end

  if ~(strcmp(what, 'run'))
    error('unsupported command')
  end

  if (isempty(show_msg))
    disp('##')
    disp('##  Initializing SymPy communication...')
    disp('##')
    disp('##  You are using the system() IPC mechanism to communicate with SymPy.')
    disp('##  This will be slow.  Every round-trip involves executing a new Python')
    disp('##  process.  Many operations involve several round-trips.')
    disp('##')
    show_msg = true;
  end

  headers = python_header();

  newl = sprintf('\n');

  %% load all the inputs into python as pickles
  s1 = python_copy_vars_to('_ins', varargin{:});

  %% the actual command
  % this will do something with _ins and produce _outs
  s2 = [cmd newl newl];

  %% output
  s3 = python_copy_vars_from('_outs');

  pyexec = octsympy_config('python');
  if (isempty(pyexec))
    pyexec = 'python';
  end

  %% FIXME: Issue #63: with new regexp code on Matlab
  % workaround:
  % octsympy_config python 'LD_LIBRARY_PATH="" python'
  % to prevent a conflict with the expat shipped with Matlab 2014a
  % See here with oracle
  % https://bugzilla.redhat.com/show_bug.cgi?id=821337
  % FIXME: make this the default on Matlab install?

  %% FIXME: Debug mode
  % it would be helpful to provide an option to output the
  % generated py file for examing.
  if (1==1)
    bigs = [headers newl s1 newl s2 newl s3 newl];
    bigs = strrep(bigs, '"', '\"');
    [status,out] = system([pyexec ' -c "' bigs '"']);
  else
    %% use a temp file
    fname = 'temp_sym_python_cmd.py';
    fd = fopen(fname, 'w');
    fprintf(fd, '# temporary autogenerated code\n\n');
    fprintf(fd, '%s\n', headers);
    fprintf(fd, '%s\n', s1);
    fprintf(fd, '%s\n', s2);
    fprintf(fd, '%s\n', s3);
    fclose(fd);
    [status,out] = system([pyexec ' ' fname]);
  end

  if status ~= 0
    status
    out
    error('system() call failed!');
  end

  % there should be two blocks
  ind = strfind(out, '<output_block>');
  assert(length(ind) == 2)
  out1 = out(ind(1):(ind(2)-1));
  % could extractblock here, but just search for keyword instead
  if (isempty(strfind(out1, 'successful')))
    error('failed to import variables to python?')
  end
  A = extractblock(out(ind(2):end));
