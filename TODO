## equality

MST: ==, define equations
SymPy: ??

MST: logical(), "structural" equivalence
SymPy: ==

MST: isAlways(), "mathematical" equivalence
SymPy: bool(LHS.expand() == RHS.expand())
> If .expand() does not help, try simplify(), trigsimp(), etc, which
> attempt more advanced transformations. For example,
[https://github.com/sympy/sympy/wiki/Faq]


## double

python generates C "%a" formatting:

  0.11 -> '0x1.c28f5c28f5c29p-4'

java might work, or write some custom code.  In first instance, I'll
use a string with many digits but it would be good to pass the
bit-exact double precision value back from sympy.


## symfuns, DE solving

symfun: probably this is:

f = Function('f')


## matrices

Fundamental choice:
(1) make a matrix array of sym objects; or
(2) use sp.Matrix in sympy.

(1+) seems easy to start with
(1-) but then sin(x) for example will need to call sin for each entry

(2-) requires some effort for functions:  A.applyfunc(sp.sin)
(2+) renders nicely already

essential issue is that scalars are not (1,1) matrices in sympy.
Could do that but, e.g., diff might not work... well we could just
generate the code to make it work.

% size.m:
function b = size(x)
  b = 6



## converting to .m function

matlabFunction() in SMT is convenient.  Parse from string?

TODO: perhaps we want a "filter" method that runs after each return
from sympy on the .text field: convert "oo" to "inf", "Abs -> abs",
etc.


