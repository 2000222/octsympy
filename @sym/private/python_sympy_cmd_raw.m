function A = python_sympy_cmd_raw(cmd, varargin)
%PYTHON_SYMPY_CMD_RAW  Run SymPy command and return strings

  fname = 'temp_sym_python_cmd.py';
  stag='<output_item>';
  etag='</output_item>';


  fd = fopen(fname, 'w');

  fprintf(fd, '# temporary autogenerated code\n\n');
  fprintf(fd, 'import sympy as sp\n');
  fprintf(fd, 'import pickle\n\n');

  %% load all the inputs into python as pickles
  fprintf(fd, 'ins = []\n\n');
  for i=1:length(varargin)
    x = varargin{i};
    fprintf(fd, '# Load pickle %d\n', i);
    fprintf(fd, 'ins.append(pickle.loads("""%s"""))\n\n', x.pickle);
  end

  %% the actual command
  fprintf(fd, cmd);
  fprintf(fd, '\nout = fcn(ins)\n\n');

  %% output
  fprintf(fd, 'print "%s"\n', stag);
  fprintf(fd, 'print "%s"\n', etag);
  fprintf(fd, 'for item in out:\n');
  fprintf(fd, '    print "%s"\n', stag);
  fprintf(fd, '    print str(item)\n', i);
  fprintf(fd, '    print "%s"\n', etag);
  fprintf(fd, '    print "%s"\n', stag);
  fprintf(fd, '    print pickle.dumps(item)\n', i);
  fprintf(fd, '    print "%s"\n', etag);

  fclose(fd);

  [status,out] = system(['python ' fname]);
  if status ~= 0
    error('failed');
    out
  end

  %% extract the output
  % should be a nicer way to do all this with regexp!
  try
    s = strfind(out, stag);
    e = strfind(out, etag);
    % detect length of newline (1 on unix, 2 on windows?)
    lnl = e(1)-s(1)-length(stag);
    A = {};
    for i = 1:(length(s)-1)
      A{i} = out( (s(i+1)+length(stag)+lnl) : (e(i+1)-1-lnl) );
    end
  catch
    error('failed to extract output')
    status, out, s, e, A
  end